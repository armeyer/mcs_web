\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{PS_printout_binary_strings}
  \pcomment{from: S09.ps1}
\end{pcomments}

\pkeywords{
  binary
  truth_tables
  program
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Describe a simple recursive procedure which, given a positive integer
argument, $n$, produces a truth table whose rows are all the assignments
of truth values to $n$ propositional variables.  For example, for $n=2$,
the table might look like:

\[\begin{array}{|c|c|}
\hline \true & \true\\
\true & \false\\
\false & \true\\
\false & \false\\
\hline
\end{array}\]

Your description can be in English, or a simple program in some
familiar language such as Scheme or Java.  If you do write a program,
be sure to include some sample output.

\begin{solution}
Start with an $n=1$ table, namely a one-column table whose
first row consists of a $\true$ entry and second row an $\false$ entry.
Build the $n+1$ table recursively by taking an $n$ table and attaching a
$\true$ at the beginning of every row, then taking another $n$ table and
attaching a $\false$ at the beginning of every row, and finally placing
the first table above the second table.

Here's a Scheme program that carries out this procedure:
\texttt{
\begin{tabbing}
(de\=fine (truth-values n)\\
   \> (if \= (= n 1) '((T) (F))\\
   \>    \> (let \=((table (truth-values (- n 1))))\\
              \>\>\> (ap\=pend\\
                \>\>\>\> (map (lambda (row) (cons 'T row)) table)\\
                \>\>\>\> (map (lambda (row) (cons 'F row)) table)))))\\
(truth-values 3)\\
;Value 17: \>\>\>((t t t) (t t f) (t f t) (t f f)\\
           \>\>\>\ (f t t) (f t f) (f f t) (f f f))
\end{tabbing}}
\end{solution}
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
