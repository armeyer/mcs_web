\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{from: S09.cp5t}
\end{pcomments}

\pkeywords{
  state_machines
  termination
  partial_correctness
  invariant
  exponentiation
  algorithm
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
%\textbf{This problem is being carried over to Friday.}

The most straightforward way to compute the $b$th power of a number, $a$,
is to multiply $a$ by itself $b$ times.  This of course requires $b-1$
multiplications.  There is another way to do it using considerably fewer
multiplications.  This algorithm is called \emph{Fast Exponentiation}:

Given inputs $a \in \reals, b \in \naturals$,
initialize registers $x,y,z$ to $a,1,b$ respectively,
and repeat the following sequence of steps until termination:
\begin{itemize}\renewcommand{\itemsep}{0pt}
\item if $z = 0$ \textbf{return} $y$ and terminate
\item $r := \text{remainder}(z,2)$
\item $z := \text{quotient}(z,2)$
\item if $r = 1$, then $y := xy$
\item $x := x^2$
\end{itemize}
We claim this algorithm always terminates and leaves $y = a^b$.

\bparts

\ppart Model this algorithm with a state machine, carefully defining
the states and transitions.

\begin{solution}
See Friday \href{http://courses.csail.mit.edu/solutions/cp5fsol.pdf}{solutions}.
\end{solution}

\ppart Verify that the predicate $P((x,y,z)) \eqdef\ [yx^z = a^b]$ is a
preserved invariant.

\ppart Prove that the algorithm is partially correct: if it halts, it does
so with $y=d$.

\ppart Prove that the algorithm terminates.

\ppart In fact, prove that it requires at most $2 \log_2 b$
multiplications for the Fast Exponentiation algorithm to compute $a^b$ for
$b>1$.

\eparts
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
