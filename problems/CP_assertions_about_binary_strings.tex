\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_assertions_about_binary_strings}
  \pcomment{from: S09.cp2t}
  \pcomment{There are a few parts commented out that could use review to
            decide whether to include or cut them.}
\end{pcomments}

\pkeywords{
  translate
  binary strings
  logic_notation
  quantifiers
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
The goal of this problem is to translate some assertions about binary
strings into logic notation.  The domain of discourse is the set of
all finite-length binary strings: $\emptystring$, 0, 1, 00, 01, 10,
11, 000, 001, \ldots.  (Here $\emptystring$ denotes the \idx{empty
  string}.)  In your translations, you may use all the ordinary logic
symbols (including \texttt{=}), variables, and the binary symbols
\texttt{0}, \texttt{1} denoting 0, 1.

A string like $\mathtt{01}x\mathtt{0}y$ of binary symbols and variables
denotes the \emph{concatenation} of the symbols and the binary strings
represented by the variables.  For example, if the value of $x$ is
\texttt{011} and the value of $y$ is \texttt{1111}, then the value of
$\mathtt{01}x\mathtt{0}y$ is the binary string \texttt{0101101111}.

Here are some examples of formulas and their English translations.  Names
for these predicates are listed in the third column so that you can reuse
them in your solutions (as we do in the definition of the predicate
{\sc no-1s} below).

\begin{center}
\begin{tabular}{lclcl}
Meaning &   Formula  & Name \\ \hline
$x$ is a prefix of $y$  & $\exists z\ (xz = y)$ & \sc{prefix}($x, y$) \\
$x$ is a substring of $y$  & $\exists u \exists v\ (uxv = y)$ & \sc{substring}($x, y$) \\
$x$ is empty or a string of 0's\quad  & $\QNOT(\text{\sc{substring}}(\mathtt{1},x))$\quad
  & \sc{no-1s}($x$)
\end{tabular}
\end{center}

\bparts

\ppart $x$ consists of three copies of some string.

\begin{solution}

$\exists y\ (x = yyy)$

\end{solution}

\ppart $x$ is an even-length string of 0's.

\begin{solution}

$\text{\sc{no-1s}}(x) \QAND \exists y\ (x = yy)$

Some students mentioned $\emptystring$ in their formulas.
Technically, this is not allowed, so they need to justify it by giving
a formula that means ``$x = \emptystring$.''  This is easy, for
example: $x = xx$.

A serious mistake was to try writing a recursive definition of a
predicate calculus formula, as in
\begin{equation}\label{recPx00y}
P(x) \eqdef x = \emptystring \QOR \exists y.\, x=00y \QAND P(y).
\end{equation}
Such recursive formulas are, by definition, \emph{not} part of
predicate calculus---with good reason.  Definition~\ref{recPx00y}
resembles a simple recursive definition of a \emph{procedure} to test
if $x$ is an even length string of \texttt{0}'s, and its meaning might
be explained in procedural terms.  But it's hard to figure out in
general what recursively defined formulas mean.  For example, let $n$
be an integer-valued variable, and suppose we tried to define a
formula, $Q(n)$, that means $n$ is positive:
\[
Q(n) \eqdef (n = 0 \QOR \QNOT(Q(n+1))) \QAND (n = 1 \QOR  Q(n-1)).
\]
might succeed in giving a procedural explanation for this example,

\end{solution}

\ppart $x$ does not contain both a 0 and a 1.

\begin{solution}

\[
\QNOT [\text{\sc{substring}}(\mathtt{0}, x) \QAND \text{\sc{substring}}(\mathtt{1}, x)]
\]

\iffalse
Another solution is
\[
\text{\sc{no-1s}}(x) \disj \text{\sc{no-0s}}(x).
\]
\fi

\end{solution}

\ppart $x$ is the binary representation of $2^k + 1$ for some
integer $k \geq 0$.

\begin{solution}
 $(x = \mathtt{10}) \QOR (\exists y\ (x = \mathtt{1}y\mathtt{1}
\QAND \text{\sc{no-1s}}(y)))$
\end{solution}


\ppart An elegant, slightly trickier way to define $\text{\sc{no-1s}}(x)$
is:
\begin{equation}\tag{*}
\text{\sc{prefix}}(x, \mathtt{0}x).
\end{equation}
Explain why~(*) is true only when $x$ is a string of 0's.

\iffalse
Explain why can't we define ``$x$ is an even-length string of 0's,'' by
\begin{equation}\tag{**}
\text{\sc{prefix}}(x, \mathtt{00}x).
\end{equation}
\fi

\begin{solution}
Prefixing $x$ with 0 rightshifts all the bits.  So the $n$th
symbol of $x$ shifts into the $(n+1)$st symbol of $0x$.  Now for $x$ to be
a prefix of $0x$, the $n+1$st symbol of $0x$ must match the $(n+1)$st
symbol of $x$.  So if $x$ satisfies~(*), the $n$th and $(n+1)$st symbols
of $x$ must match.  This holds for all $n>0$ up to the length of $x$, that
is, \emph{all} the symbols of $x$ must be the same.  In addition, if
$x\neq \lambda$, it must start with 0.  Therefore, if $x$ satisfies~(*),
all its symbols must be 0's.

Note that it's easy to see, conversely, that if $x = \lambda$ or $x$ is
all 0's, then of course it satisfies~(*).
\end{solution}

\eparts

\end{problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
